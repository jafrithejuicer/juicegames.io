<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Agar.io Clone</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:#b7dcff; font-family:Calibri,sans-serif; }
canvas { display:block; }
#namePopup {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7);
  display:flex; align-items:center; justify-content:center; flex-direction:column; color:white; font-size:24px;
}
#nameInput { padding:10px; font-size:20px; border-radius:6px; border:none; }
#playBtn { padding:10px 20px; margin-top:10px; background:#4CAF50; border:none; border-radius:6px; cursor:pointer; font-size:20px; color:white; }
#leaderboard { position:absolute; top:20px; left:20px; background:rgba(0,0,0,0.5); padding:10px; border-radius:8px; font-size:16px; color:white; }
#minimap { position:absolute; bottom:20px; right:20px; background:rgba(0,0,0,0.3); border:2px solid white; }
</style>
</head>
<body>
<div id="namePopup">
  <div>Enter your name</div>
  <input id="nameInput" maxlength="16" placeholder="Your Name">
  <button id="playBtn">Play</button>
</div>
<div id="leaderboard"></div>
<canvas id="game"></canvas>
<canvas id="minimap" width="200" height="150"></canvas>
<script>
const canvas=document.getElementById("game"), ctx=canvas.getContext("2d");
canvas.width=window.innerWidth; canvas.height=window.innerHeight;

const miniCanvas=document.getElementById("minimap"), miniCtx=miniCanvas.getContext("2d");

const MAP_SIZE=3000, FOOD_COUNT=2000, BOT_COUNT=15;
const BORDER_THICKNESS = 30;

let player=null, bots=[], food=[], splitCells=[], keys={}, mouseX=0, mouseY=0;
let camera={x:0,y:0}; // for smoothing

// helpers
const rand=(min,max)=>Math.random()*(max-min)+min;
const randColor=()=>`hsl(${Math.floor(Math.random()*360)},70%,60%)`;
const randName=()=>["Nebula","Phantom","Orion","Venom","Nova","Titan","Echo","Rider","Vortex"].sort(()=>0.5-Math.random())[0];

function createPlayer(name){ return {name,x:MAP_SIZE/2,y:MAP_SIZE/2,size:40,color:randColor()}; }
function createBot(){ return {name:randName(),x:rand(0,MAP_SIZE),y:rand(0,MAP_SIZE),size:rand(50,150),color:randColor()}; }
function createFood(){ return {x:rand(0,MAP_SIZE),y:rand(0,MAP_SIZE),size:rand(3,8),color:randColor()}; }

function init(){
  for(let i=0;i<FOOD_COUNT;i++) food.push(createFood());
  for(let i=0;i<BOT_COUNT;i++) bots.push(createBot());
}

// movement
window.addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
window.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);
window.addEventListener("mousemove",e=>mouseX=e.clientX,mouseY=e.clientY);

function updatePlayer(){
  if(!player) return;
  const speed = 7 / Math.sqrt(player.size/40);

  if(keys['w']) player.y-=speed;
  if(keys['s']) player.y+=speed;
  if(keys['a']) player.x-=speed;
  if(keys['d']) player.x+=speed;

  // cursor movement dominance if no WASD
  if(!(keys['w']||keys['a']||keys['s']||keys['d'])){
    let dx = mouseX-canvas.width/2;
    let dy = mouseY-canvas.height/2;
    let dist = Math.hypot(dx,dy);
    if(dist>1){ dx/=dist; dy/=dist; player.x+=dx*speed; player.y+=dy*speed; }
  }

  // eat food
  for(let i=food.length-1;i>=0;i--){
    const f=food[i];
    const d=Math.hypot(player.x-f.x,player.y-f.y);
    if(d<player.size+f.size){ player.size+=f.size*0.3; food.splice(i,1); }
  }

  // bots collisions
  for(let i=bots.length-1;i>=0;i--){
    const b=bots[i];
    const d=Math.hypot(player.x-b.x,player.y-b.y);
    if(d<player.size+b.size){
      if(player.size>b.size*1.1){ player.size+=b.size*0.4; bots[i]=createBot(); }
      else if(b.size>player.size*1.1){ player=createPlayer(player.name); }
    }
  }

  // borders
  if(player.x<BORDER_THICKNESS){ player.x=BORDER_THICKNESS; player.size-=0.3; }
  if(player.y<BORDER_THICKNESS){ player.y=BORDER_THICKNESS; player.size-=0.3; }
  if(player.x>MAP_SIZE-BORDER_THICKNESS){ player.x=MAP_SIZE-BORDER_THICKNESS; player.size-=0.3; }
  if(player.y>MAP_SIZE-BORDER_THICKNESS){ player.y=MAP_SIZE-BORDER_THICKNESS; player.size-=0.3; }

  if(player.size<10) player=createPlayer(player.name);
}

function updateBots(){
  bots.forEach(b=>{
    let angle=Math.random()*Math.PI*2;
    b.x+=Math.cos(angle)*1.5; b.y+=Math.sin(angle)*1.5;
    if(b.x<BORDER_THICKNESS) b.x=BORDER_THICKNESS;
    if(b.y<BORDER_THICKNESS) b.y=BORDER_THICKNESS;
    if(b.x>MAP_SIZE-BORDER_THICKNESS) b.x=MAP_SIZE-BORDER_THICKNESS;
    if(b.y>MAP_SIZE-BORDER_THICKNESS) b.y=MAP_SIZE-BORDER_THICKNESS;
  });
}

function handleSplitAndEject(){
  // SPACE to split
  if(keys[' ']){
    const angle = Math.atan2(mouseY-canvas.height/2, mouseX-canvas.width/2);
    const newSize = player.size/2;
    if(newSize>10){
      splitCells.push({x:player.x,y:player.y,size:newSize,vx:Math.cos(angle)*20,vy:Math.sin(angle)*20,color:player.color});
      player.size=newSize;
    }
    keys[' ']=false;
  }
  // E to eject
  if(keys['e']){
    player.size-=Math.min(5,player.size*0.1);
    keys['e']=false;
  }

  // move split cells
  for(let i=splitCells.length-1;i>=0;i--){
    const c=splitCells[i];
    c.x+=c.vx; c.y+=c.vy;
    c.vx*=0.95; c.vy*=0.95;

    // collide with bots
    for(let j=bots.length-1;j>=0;j--){
      const b=bots[j];
      const d=Math.hypot(c.x-b.x,c.y-b.y);
      if(d<c.size+b.size){
        if(c.size>b.size*1.1){ c.size+=b.size*0.4; bots[j]=createBot(); splitCells.splice(i,1); break; }
        else if(b.size>c.size*1.1){ b.size+=c.size; splitCells.splice(i,1); break; }
      }
    }
    if(c.size<5) splitCells.splice(i,1);
  }
}

function drawLeaderboard(){
  const lb=document.getElementById("leaderboard");
  const all=[player,...bots].sort((a,b)=>b.size-a.size).slice(0,5);
  let html="Leaderboard:<br>";
  all.forEach((p,i)=>{ html+=`${i==0?"ðŸ‘‘ ":""}${p.name}: ${Math.floor(p.size)}<br>`; });
  lb.innerHTML=html;
}

function drawMinimap(){
  const w=miniCanvas.width, h=miniCanvas.height;
  miniCtx.setTransform(1,0,0,1,0,0);
  miniCtx.clearRect(0,0,w,h);
  miniCtx.fillStyle="rgba(255,255,255,0.3)";
  miniCtx.fillRect(0,0,w,h);

  const scaleX=w/MAP_SIZE, scaleY=h/MAP_SIZE;
  // food
  food.forEach(f=>{ miniCtx.fillStyle=f.color; miniCtx.fillRect(f.x*scaleX,f.y*scaleY,2,2); });
  // bots
  bots.forEach(b=>{ miniCtx.fillStyle=b.color; miniCtx.fillRect(b.x*scaleX,b.y*scaleY,4,4); });
  // player
  miniCtx.fillStyle=player.color; miniCtx.fillRect(player.x*scaleX-3,player.y*scaleY-3,6,6);
}

function draw(){
  if(!player) return;

  // smooth camera
  camera.x += (player.x - camera.x)*0.1;
  camera.y += (player.y - camera.y)*0.1;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const zoom=200/player.size;
  ctx.setTransform(zoom,0,0,zoom,canvas.width/2-camera.x*zoom,canvas.height/2-camera.y*zoom);

  // borders
  ctx.strokeStyle="red"; ctx.lineWidth=BORDER_THICKNESS*zoom;
  ctx.strokeRect(0,0,MAP_SIZE,MAP_SIZE);

  // food
  food.forEach(f=>{ ctx.fillStyle=f.color; ctx.beginPath(); ctx.arc(f.x,f.y,f.size,0,Math.PI*2); ctx.fill(); });

  // bots
  bots.forEach(b=>{
    ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="white"; ctx.font=`${b.size/2}px Calibri`; ctx.textAlign="center"; ctx.fillText(b.name,b.x,b.y+5);
  });

  // split cells
  splitCells.forEach(c=>{
    ctx.fillStyle=c.color; ctx.beginPath(); ctx.arc(c.x,c.y,c.size,0,Math.PI*2); ctx.fill();
  });

  // player
  ctx.fillStyle=player.color; ctx.beginPath(); ctx.arc(player.x,player.y,player.size,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="white"; ctx.font=`${player.size/2}px Calibri`; ctx.textAlign="center"; ctx.fillText(player.name,player.x,player.y+5);

  drawMinimap();
}

function loop(){
  updatePlayer(); updateBots(); handleSplitAndEject(); draw(); drawLeaderboard();
  requestAnimationFrame(loop);
}

document.getElementById("playBtn").onclick=()=>{
  const name=document.getElementById("nameInput").value.trim();
  if(!name) return;
  player=createPlayer(name);
  document.getElementById("namePopup").style.display="none";
  init(); loop();
};
</script>
</body>
</html>


